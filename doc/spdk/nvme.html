<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Module nvme</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #666;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0.25em 10px 0.25em 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */

ul.simple > li {
  margin-bottom: 0.5em }

ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
  div.pragma {
    display: none;
  }
  span.pragmabegin {
    cursor: pointer;
  }
  span.pragmaend {
    cursor: pointer;
  }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}
</style>

<script type="text/javascript" src="../dochack.js"></script>

<script type="text/javascript">
function togglepragma(d) {
  if (d.style.display != 'inline')
    d.style.display = 'inline';
  else
    d.style.display = 'none';
}

function main() {
  var elements = document.getElementsByClassName("pragmabegin");
  for (var i = 0; i < elements.length; ++i) {
    var e = elements[i];
    e.onclick = function(event) {
      togglepragma(event.target.nextSibling);
    };
  }
  var elements = document.getElementsByClassName("pragmaend");
  for (var i = 0; i < elements.length; ++i) {
    var e = elements[i];
    e.onclick = function(event) {
      togglepragma(event.target.previousSibling);
    };
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Module nvme</h1>
    <div class="row">
  <div class="three columns">
  <div>
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr* = object"><wbr />spdk_<wbr />nvme_<wbr />ctrlr<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_opts"
    title="spdk_nvme_ctrlr_opts* = object
  num_io_queues*: uint32 ## *
                       ##  Number of I&#x2F;O queues to request (used to set Number of Queues feature)
                       ## 
                       ## *
                       ##  Enable submission queue in controller memory buffer
                       ## 
  use_cmb_sqs*: bool           ## *
                   ##  Type of arbitration mechanism
                   ## 
  arb_mechanism*: spdk_nvme_cc_ams"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />opts<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_probe_cb"
    title="spdk_nvme_probe_cb* = proc (cb_ctx: pointer; pci_dev: ptr spdk_pci_device;
                         opts: ptr spdk_nvme_ctrlr_opts): bool"><wbr />spdk_<wbr />nvme_<wbr />probe_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_attach_cb"
    title="spdk_nvme_attach_cb* = proc (cb_ctx: pointer; pci_dev: ptr spdk_pci_device;
                          ctrlr: ptr spdk_nvme_ctrlr;
                          opts: ptr spdk_nvme_ctrlr_opts)"><wbr />spdk_<wbr />nvme_<wbr />attach_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_remove_cb"
    title="spdk_nvme_remove_cb* = proc (cb_ctx: pointer; ctrlr: ptr spdk_nvme_ctrlr)"><wbr />spdk_<wbr />nvme_<wbr />remove_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_cmd_cb"
    title="spdk_nvme_cmd_cb* = proc (a2: pointer; a3: ptr spdk_nvme_cpl)"><wbr />spdk_<wbr />nvme_<wbr />cmd_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_aer_cb"
    title="spdk_nvme_aer_cb* = proc (aer_cb_arg: pointer; a3: ptr spdk_nvme_cpl)"><wbr />spdk_<wbr />nvme_<wbr />aer_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_qpair"
    title="spdk_nvme_qpair* = object"><wbr />spdk_<wbr />nvme_<wbr />qpair<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns"
    title="spdk_nvme_ns* = object"><wbr />spdk_<wbr />nvme_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_flags"
    title="spdk_nvme_ns_flags* = enum
  SPDK_NVME_NS_DEALLOCATE_SUPPORTED = 0x00000001, ## *&lt; The deallocate command is supported
  SPDK_NVME_NS_FLUSH_SUPPORTED = 0x00000002, ## *&lt; The flush command is supported
  SPDK_NVME_NS_RESERVATION_SUPPORTED = 0x00000004, ## *&lt; The reservation command is supported
  SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED = 0x00000008, ## *&lt; The write zeroes command is supported
  SPDK_NVME_NS_DPS_PI_SUPPORTED = 0x00000010, ## *&lt; The end-to-end data protection is supported
  SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED = 0x00000020 ## *&lt; The extended lba format is supported,
                                                ## 							      metadata is transferred as a contiguous
                                                ## 							      part of the logical block that it is associated with"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />flags<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_req_reset_sgl_cb"
    title="spdk_nvme_req_reset_sgl_cb* = proc (cb_arg: pointer; offset: uint32)"><wbr />spdk_<wbr />nvme_<wbr />req_<wbr />reset_<wbr />sgl_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_req_next_sge_cb"
    title="spdk_nvme_req_next_sge_cb* = proc (cb_arg: pointer; address: ptr uint64;
                                length: ptr uint32): cint"><wbr />spdk_<wbr />nvme_<wbr />req_<wbr />next_<wbr />sge_<wbr />cb<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#8" id="58">Vars</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#spdk_nvme_retry_count"
    title="spdk_nvme_retry_count*: int32"><wbr />spdk_<wbr />nvme_<wbr />retry_<wbr />count<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libspdk"
    title="libspdk* = &quot;libspdk.dll&quot;"><wbr />libspdk<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#SPDK_NVME_DEFAULT_RETRY_COUNT"
    title="SPDK_NVME_DEFAULT_RETRY_COUNT* = (4)"><wbr />SPDK_<wbr />NVME_<wbr />DEFAULT_<wbr />RETRY_<wbr />COUNT<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#spdk_nvme_probe,pointer,spdk_nvme_probe_cb,spdk_nvme_attach_cb,spdk_nvme_remove_cb"
    title="spdk_nvme_probe*(cb_ctx: pointer; probe_cb: spdk_nvme_probe_cb;
                 attach_cb: spdk_nvme_attach_cb; remove_cb: spdk_nvme_remove_cb): cint"><wbr />spdk_<wbr />nvme_<wbr />probe<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_detach,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_detach*(ctrlr: ptr spdk_nvme_ctrlr): cint"><wbr />spdk_<wbr />nvme_<wbr />detach<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_reset,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_reset*(ctrlr: ptr spdk_nvme_ctrlr): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />reset<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_get_data,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_get_data*(ctrlr: ptr spdk_nvme_ctrlr): ptr spdk_nvme_ctrlr_data"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />get_<wbr />data<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_get_regs_cap,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_get_regs_cap*(ctrlr: ptr spdk_nvme_ctrlr): spdk_nvme_cap_register"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />get_<wbr />regs_<wbr />cap<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_get_regs_vs,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_get_regs_vs*(ctrlr: ptr spdk_nvme_ctrlr): spdk_nvme_vs_register"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />get_<wbr />regs_<wbr />vs<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_get_num_ns,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_get_num_ns*(ctrlr: ptr spdk_nvme_ctrlr): uint32"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />get_<wbr />num_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_is_log_page_supported,ptr.spdk_nvme_ctrlr,uint8"
    title="spdk_nvme_ctrlr_is_log_page_supported*(ctrlr: ptr spdk_nvme_ctrlr; log_page: uint8): bool"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />is_<wbr />log_<wbr />page_<wbr />supported<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_is_feature_supported,ptr.spdk_nvme_ctrlr,uint8"
    title="spdk_nvme_ctrlr_is_feature_supported*(ctrlr: ptr spdk_nvme_ctrlr;
                                      feature_code: uint8): bool"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />is_<wbr />feature_<wbr />supported<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_register_aer_callback,ptr.spdk_nvme_ctrlr,spdk_nvme_aer_cb,pointer"
    title="spdk_nvme_ctrlr_register_aer_callback*(ctrlr: ptr spdk_nvme_ctrlr;
                                       aer_cb_fn: spdk_nvme_aer_cb;
                                       aer_cb_arg: pointer)"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />register_<wbr />aer_<wbr />callback<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_alloc_io_qpair,ptr.spdk_nvme_ctrlr,spdk_nvme_qprio"
    title="spdk_nvme_ctrlr_alloc_io_qpair*(ctrlr: ptr spdk_nvme_ctrlr; qprio: spdk_nvme_qprio): ptr spdk_nvme_qpair"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />alloc_<wbr />io_<wbr />qpair<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_free_io_qpair,ptr.spdk_nvme_qpair"
    title="spdk_nvme_ctrlr_free_io_qpair*(qpair: ptr spdk_nvme_qpair): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />free_<wbr />io_<wbr />qpair<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_cmd_io_raw,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_qpair,ptr.spdk_nvme_cmd,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ctrlr_cmd_io_raw*(ctrlr: ptr spdk_nvme_ctrlr; qpair: ptr spdk_nvme_qpair;
                            cmd: ptr spdk_nvme_cmd; buf: pointer; len: uint32;
                            cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />cmd_<wbr />io_<wbr />raw<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_qpair_process_completions,ptr.spdk_nvme_qpair,uint32"
    title="spdk_nvme_qpair_process_completions*(qpair: ptr spdk_nvme_qpair;
                                     max_completions: uint32): int32"><wbr />spdk_<wbr />nvme_<wbr />qpair_<wbr />process_<wbr />completions<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_cmd_admin_raw,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_cmd,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ctrlr_cmd_admin_raw*(ctrlr: ptr spdk_nvme_ctrlr; cmd: ptr spdk_nvme_cmd;
                               buf: pointer; len: uint32; cb_fn: spdk_nvme_cmd_cb;
                               cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />cmd_<wbr />admin_<wbr />raw<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_process_admin_completions,ptr.spdk_nvme_ctrlr"
    title="spdk_nvme_ctrlr_process_admin_completions*(ctrlr: ptr spdk_nvme_ctrlr): int32"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />process_<wbr />admin_<wbr />completions<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_get_ns,ptr.spdk_nvme_ctrlr,uint32"
    title="spdk_nvme_ctrlr_get_ns*(ctrlr: ptr spdk_nvme_ctrlr; ns_id: uint32): ptr spdk_nvme_ns"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />get_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_cmd_get_log_page,ptr.spdk_nvme_ctrlr,uint8,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ctrlr_cmd_get_log_page*(ctrlr: ptr spdk_nvme_ctrlr; log_page: uint8;
                                  nsid: uint32; payload: pointer;
                                  payload_size: uint32; cb_fn: spdk_nvme_cmd_cb;
                                  cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />cmd_<wbr />get_<wbr />log_<wbr />page<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_cmd_set_feature,ptr.spdk_nvme_ctrlr,uint8,uint32,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ctrlr_cmd_set_feature*(ctrlr: ptr spdk_nvme_ctrlr; feature: uint8;
                                 cdw11: uint32; cdw12: uint32; payload: pointer;
                                 payload_size: uint32; cb_fn: spdk_nvme_cmd_cb;
                                 cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />cmd_<wbr />set_<wbr />feature<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_cmd_get_feature,ptr.spdk_nvme_ctrlr,uint8,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ctrlr_cmd_get_feature*(ctrlr: ptr spdk_nvme_ctrlr; feature: uint8;
                                 cdw11: uint32; payload: pointer;
                                 payload_size: uint32; cb_fn: spdk_nvme_cmd_cb;
                                 cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />cmd_<wbr />get_<wbr />feature<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_attach_ns,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_ctrlr_list"
    title="spdk_nvme_ctrlr_attach_ns*(ctrlr: ptr spdk_nvme_ctrlr; nsid: uint32;
                           payload: ptr spdk_nvme_ctrlr_list): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />attach_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_detach_ns,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_ctrlr_list"
    title="spdk_nvme_ctrlr_detach_ns*(ctrlr: ptr spdk_nvme_ctrlr; nsid: uint32;
                           payload: ptr spdk_nvme_ctrlr_list): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />detach_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_create_ns,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_ns_data"
    title="spdk_nvme_ctrlr_create_ns*(ctrlr: ptr spdk_nvme_ctrlr;
                           payload: ptr spdk_nvme_ns_data): uint32"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />create_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_delete_ns,ptr.spdk_nvme_ctrlr,uint32"
    title="spdk_nvme_ctrlr_delete_ns*(ctrlr: ptr spdk_nvme_ctrlr; nsid: uint32): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />delete_<wbr />ns<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_format,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_format"
    title="spdk_nvme_ctrlr_format*(ctrlr: ptr spdk_nvme_ctrlr; nsid: uint32;
                        format: ptr spdk_nvme_format): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />format<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ctrlr_update_firmware,ptr.spdk_nvme_ctrlr,pointer,uint32,cint"
    title="spdk_nvme_ctrlr_update_firmware*(ctrlr: ptr spdk_nvme_ctrlr; payload: pointer;
                                 size: uint32; slot: cint): cint"><wbr />spdk_<wbr />nvme_<wbr />ctrlr_<wbr />update_<wbr />firmware<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_data,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_data*(ns: ptr spdk_nvme_ns): ptr spdk_nvme_ns_data"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />data<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_id,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_id*(ns: ptr spdk_nvme_ns): uint32"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />id<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_is_active,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_is_active*(ns: ptr spdk_nvme_ns): bool"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />is_<wbr />active<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_max_io_xfer_size,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_max_io_xfer_size*(ns: ptr spdk_nvme_ns): uint32"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />max_<wbr />io_<wbr />xfer_<wbr />size<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_sector_size,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_sector_size*(ns: ptr spdk_nvme_ns): uint32"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />sector_<wbr />size<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_num_sectors,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_num_sectors*(ns: ptr spdk_nvme_ns): uint64"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />num_<wbr />sectors<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_size,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_size*(ns: ptr spdk_nvme_ns): uint64"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />size<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_pi_type,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_pi_type*(ns: ptr spdk_nvme_ns): spdk_nvme_pi_type"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />pi_<wbr />type<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_md_size,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_md_size*(ns: ptr spdk_nvme_ns): uint32"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />md_<wbr />size<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_supports_extended_lba,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_supports_extended_lba*(ns: ptr spdk_nvme_ns): bool"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />supports_<wbr />extended_<wbr />lba<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_get_flags,ptr.spdk_nvme_ns"
    title="spdk_nvme_ns_get_flags*(ns: ptr spdk_nvme_ns): uint32"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />get_<wbr />flags<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_write,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"
    title="spdk_nvme_ns_cmd_write*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                        payload: pointer; lba: uint64; lba_count: uint32;
                        cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer; io_flags: uint32): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />write<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_writev,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,spdk_nvme_req_reset_sgl_cb,spdk_nvme_req_next_sge_cb"
    title="spdk_nvme_ns_cmd_writev*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                         lba: uint64; lba_count: uint32; cb_fn: spdk_nvme_cmd_cb;
                         cb_arg: pointer; io_flags: uint32;
                         reset_sgl_fn: spdk_nvme_req_reset_sgl_cb;
                         next_sge_fn: spdk_nvme_req_next_sge_cb): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />writev<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_write_with_md,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,uint16,uint16"
    title="spdk_nvme_ns_cmd_write_with_md*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                                payload: pointer; metadata: pointer; lba: uint64;
                                lba_count: uint32; cb_fn: spdk_nvme_cmd_cb;
                                cb_arg: pointer; io_flags: uint32;
                                apptag_mask: uint16; apptag: uint16): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />write_<wbr />with_<wbr />md<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_write_zeroes,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"
    title="spdk_nvme_ns_cmd_write_zeroes*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                               lba: uint64; lba_count: uint32;
                               cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer;
                               io_flags: uint32): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />write_<wbr />zeroes<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_read,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"
    title="spdk_nvme_ns_cmd_read*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                       payload: pointer; lba: uint64; lba_count: uint32;
                       cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer; io_flags: uint32): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />read<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_readv,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,spdk_nvme_req_reset_sgl_cb,spdk_nvme_req_next_sge_cb"
    title="spdk_nvme_ns_cmd_readv*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair; lba: uint64;
                        lba_count: uint32; cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer;
                        io_flags: uint32;
                        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb;
                        next_sge_fn: spdk_nvme_req_next_sge_cb): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />readv<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_read_with_md,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,uint16,uint16"
    title="spdk_nvme_ns_cmd_read_with_md*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                               payload: pointer; metadata: pointer; lba: uint64;
                               lba_count: uint32; cb_fn: spdk_nvme_cmd_cb;
                               cb_arg: pointer; io_flags: uint32;
                               apptag_mask: uint16; apptag: uint16): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />read_<wbr />with_<wbr />md<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_deallocate,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint16,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_deallocate*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                             payload: pointer; num_ranges: uint16;
                             cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />deallocate<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_flush,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_flush*(ns: ptr spdk_nvme_ns; qpair: ptr spdk_nvme_qpair;
                        cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />flush<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_reservation_register,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_register_data,bool,spdk_nvme_reservation_register_action,spdk_nvme_reservation_register_cptpl,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_reservation_register*(ns: ptr spdk_nvme_ns;
                                       qpair: ptr spdk_nvme_qpair; payload: ptr spdk_nvme_reservation_register_data;
                                       ignore_key: bool; action: spdk_nvme_reservation_register_action;
    cptpl: spdk_nvme_reservation_register_cptpl; cb_fn: spdk_nvme_cmd_cb;
                                       cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />reservation_<wbr />register<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_reservation_release,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_key_data,bool,spdk_nvme_reservation_release_action,spdk_nvme_reservation_type,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_reservation_release*(ns: ptr spdk_nvme_ns;
                                      qpair: ptr spdk_nvme_qpair; payload: ptr spdk_nvme_reservation_key_data;
                                      ignore_key: bool; action: spdk_nvme_reservation_release_action;
                                      `type`: spdk_nvme_reservation_type;
                                      cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />reservation_<wbr />release<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_reservation_acquire,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_acquire_data,bool,spdk_nvme_reservation_acquire_action,spdk_nvme_reservation_type,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_reservation_acquire*(ns: ptr spdk_nvme_ns;
                                      qpair: ptr spdk_nvme_qpair; payload: ptr spdk_nvme_reservation_acquire_data;
                                      ignore_key: bool; action: spdk_nvme_reservation_acquire_action;
                                      `type`: spdk_nvme_reservation_type;
                                      cb_fn: spdk_nvme_cmd_cb; cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />reservation_<wbr />acquire<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_ns_cmd_reservation_report,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint32,spdk_nvme_cmd_cb,pointer"
    title="spdk_nvme_ns_cmd_reservation_report*(ns: ptr spdk_nvme_ns;
                                     qpair: ptr spdk_nvme_qpair; payload: pointer;
                                     len: uint32; cb_fn: spdk_nvme_cmd_cb;
                                     cb_arg: pointer): cint"><wbr />spdk_<wbr />nvme_<wbr />ns_<wbr />cmd_<wbr />reservation_<wbr />report<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#spdk_nvme_request_size,"
    title="spdk_nvme_request_size*(): csize"><wbr />spdk_<wbr />nvme_<wbr />request_<wbr />size<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  <p class="module-desc"><dl class="docutils"><dt>-</dt>
<dd><p>BSD LICENSE</p>
<p>Copyright (c) Intel Corporation. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<blockquote><p><ul class="simple"><li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Intel Corporation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
</p></blockquote>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</dd>
<dt>* file</dt>
<dd>NVMe driver public API</dd>
</dl>
</p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="pci.html">pci</a>, <a class="reference external" href="nvme_spec.html">nvme_spec</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<dt id="spdk_nvme_ctrlr"><a name="spdk_nvme_ctrlr"></a><pre><span class="Identifier">spdk_nvme_ctrlr</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  </pre></dt>
<dd>
<ul class="simple"><li>brief Opaque handle to a controller. Returned by ref spdk_nvme_probe()'s attach_cb.</li>
</ul>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L57"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L57" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_opts"><a name="spdk_nvme_ctrlr_opts"></a><pre><span class="Identifier">spdk_nvme_ctrlr_opts</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">num_io_queues</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Comment">## *</span>
                       <span class="Comment">##  Number of I/O queues to request (used to set Number of Queues feature)</span>
                       <span class="Comment">## </span>
                       <span class="Comment">## *</span>
                       <span class="Comment">##  Enable submission queue in controller memory buffer</span>
                       <span class="Comment">## </span>
  <span class="Identifier">use_cmb_sqs</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>           <span class="Comment">## *</span>
                   <span class="Comment">##  Type of arbitration mechanism</span>
                   <span class="Comment">## </span>
  <span class="Identifier">arb_mechanism</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cc_ams</span>
</pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief NVMe controller initialization options.</p>
<p>A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to allow the user to request non-default options, and the actual options enabled on the controller will be provided during the attach callback.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L63"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L63" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_probe_cb"><a name="spdk_nvme_probe_cb"></a><pre><span class="Identifier">spdk_nvme_probe_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb_ctx</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pci_dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_pci_device</span><span class="Other">;</span>
                         <span class="Identifier">opts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr_opts</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Callback for spdk_nvme_probe() enumeration.</p>
<p>param opts NVMe controller initialization options.  This structure will be populated with the default values on entry, and the user callback may update any options to request a different value.  The controller may not support all requested parameters, so the final values will be provided during the attach callback. return true to attach to this device.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L85"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L85" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_attach_cb"><a name="spdk_nvme_attach_cb"></a><pre><span class="Identifier">spdk_nvme_attach_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb_ctx</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pci_dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_pci_device</span><span class="Other">;</span>
                          <span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
                          <span class="Identifier">opts</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr_opts</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Callback for spdk_nvme_probe() to report a device that has been attached to the userspace NVMe driver.</p>
<p>param opts NVMe controller initialization options that were actually used.  Options may differ from the requested options from the probe call depending on what the controller supports.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L99"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L99" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_remove_cb"><a name="spdk_nvme_remove_cb"></a><pre><span class="Identifier">spdk_nvme_remove_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb_ctx</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Callback for spdk_nvme_probe() to report that a device attached to the userspace NVMe driver has been removed from the system.</p>
<p>param ctrlr NVMe controller instance that was removed.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L111"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L111" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_cmd_cb"><a name="spdk_nvme_cmd_cb"></a><pre><span class="Identifier">spdk_nvme_cmd_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">a2</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">a3</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_cpl</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Signature for callback function invoked when a command is completed.</p>
<p>The spdk_nvme_cpl parameter contains the completion status.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L233"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L233" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_aer_cb"><a name="spdk_nvme_aer_cb"></a><pre><span class="Identifier">spdk_nvme_aer_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">aer_cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">a3</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_cpl</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><dl class="docutils"><dt>Signature for callback function invoked when an asynchronous error</dt>
<dd>request command is completed.</dd>
<dt>The aer_cb_arg parameter is set to the context specified by</dt>
<dd>spdk_nvme_register_aer_callback().</dd>
<dt>The spdk_nvme_cpl parameter contains the completion status of the</dt>
<dd>asynchronous event request that was completed.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L241"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L241" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_qpair"><a name="spdk_nvme_qpair"></a><pre><span class="Identifier">spdk_nvme_qpair</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  </pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Opaque handle to a queue pair.</p>
<p>I/O queue pairs may be allocated using spdk_nvme_ctrlr_alloc_io_qpair().</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L257"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L257" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns"><a name="spdk_nvme_ns"></a><pre><span class="Identifier">spdk_nvme_ns</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  </pre></dt>
<dd>
<ul class="simple"><li>brief Opaque handle to a namespace. Obtained by calling spdk_nvme_ctrlr_get_ns().</li>
</ul>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L369"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L369" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_flags"><a name="spdk_nvme_ns_flags"></a><pre><span class="Identifier">spdk_nvme_ns_flags</span><span class="Operator">*</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">sizeof</span><span class="Other">(</span><span class="Identifier">cint</span><span class="Other">)</span></div><span class="Other pragmaend">.}</span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">SPDK_NVME_NS_DEALLOCATE_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## *&lt; The deallocate command is supported</span>
  <span class="Identifier">SPDK_NVME_NS_FLUSH_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span> <span class="Comment">## *&lt; The flush command is supported</span>
  <span class="Identifier">SPDK_NVME_NS_RESERVATION_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span><span class="Other">,</span> <span class="Comment">## *&lt; The reservation command is supported</span>
  <span class="Identifier">SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span><span class="Other">,</span> <span class="Comment">## *&lt; The write zeroes command is supported</span>
  <span class="Identifier">SPDK_NVME_NS_DPS_PI_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span><span class="Other">,</span> <span class="Comment">## *&lt; The end-to-end data protection is supported</span>
  <span class="Identifier">SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED</span> <span class="Other">=</span> <span class="DecNumber">0x00000020</span> <span class="Comment">## *&lt; The extended lba format is supported,</span>
                                                <span class="Comment">## 							      metadata is transferred as a contiguous</span>
                                                <span class="Comment">## 							      part of the logical block that it is associated with</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Namespace command support flags.</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L657"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L657" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_req_reset_sgl_cb"><a name="spdk_nvme_req_reset_sgl_cb"></a><pre><span class="Identifier">spdk_nvme_req_reset_sgl_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Restart the SGL walk to the specified offset when the command has scattered payloads.</p>
<p>The cb_arg parameter is the value passed to readv/writev.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L682"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L682" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_req_next_sge_cb"><a name="spdk_nvme_req_next_sge_cb"></a><pre><span class="Identifier">spdk_nvme_req_next_sge_cb</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">address</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint64</span><span class="Other">;</span>
                                <span class="Identifier">length</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked.</p>
<p>The cb_arg parameter is the value passed to readv/writev. The address parameter contains the physical address of this segment. The length parameter contains the length of this physical segment.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L690"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L690" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>
<div class="section" id="8">
<h1><a class="toc-backref" href="#8">Vars</a></h1>
<dl class="item">
<dt id="spdk_nvme_retry_count"><a name="spdk_nvme_retry_count"></a><pre><span class="Identifier">spdk_nvme_retry_count</span><span class="Operator">*</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_retry_count&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span><span class="Other">:</span> <span class="Identifier">int32</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L53"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L53" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<dt id="libspdk"><a name="libspdk"></a><pre><span class="Identifier">libspdk</span><span class="Operator">*</span> <span class="Other">=</span> <span class="StringLit">&quot;libspdk.dll&quot;</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L4"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L4" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="SPDK_NVME_DEFAULT_RETRY_COUNT"><a name="SPDK_NVME_DEFAULT_RETRY_COUNT"></a><pre><span class="Identifier">SPDK_NVME_DEFAULT_RETRY_COUNT</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">4</span><span class="Other">)</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L51"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L51" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="spdk_nvme_probe"><a name="spdk_nvme_probe,pointer,spdk_nvme_probe_cb,spdk_nvme_attach_cb,spdk_nvme_remove_cb"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_probe</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">cb_ctx</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">probe_cb</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_probe_cb</span><span class="Other">;</span>
                     <span class="Identifier">attach_cb</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_attach_cb</span><span class="Other">;</span>
                     <span class="Identifier">remove_cb</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_remove_cb</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_probe&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Enumerate the NVMe devices attached to the system and attach the userspace NVMe driver to them if desired.</p>
<p>param cb_ctx Opaque value which will be passed back in cb_ctx parameter of the callbacks. param probe_cb will be called once per NVMe device found in the system. param attach_cb will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. param remove_cb will be called for devices that were attached in a previous spdk_nvme_probe() call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</p>
<p>If called more than once, only devices that are not already attached to the SPDK NVMe driver will be reported.</p>
<p>To stop using the the controller and release its associated resources, call ref spdk_nvme_detach with the spdk_nvme_ctrlr instance returned by this function.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L120"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L120" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_detach"><a name="spdk_nvme_detach,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_detach</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_detach&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Detaches specified device returned by ref spdk_nvme_probe()'s attach_cb from the NVMe driver.</p>
<p>On success, the spdk_nvme_ctrlr handle is no longer valid.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L143"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L143" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_reset"><a name="spdk_nvme_ctrlr_reset,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_reset</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_reset&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Perform a full hardware reset of the NVMe controller.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<p>Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data() may be invalidated by calling this function.  The number of namespaces as returned by spdk_nvme_ctrlr_get_num_ns() may also change.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L155"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L155" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_get_data"><a name="spdk_nvme_ctrlr_get_data,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_get_data</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr_data</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_get_data&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the identify controller data as defined by the NVMe specification.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L168"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L168" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_get_regs_cap"><a name="spdk_nvme_ctrlr_get_regs_cap,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_get_regs_cap</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cap_register</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_get_regs_cap&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the NVMe controller CAP (Capabilities) register.</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L179"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L179" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_get_regs_vs"><a name="spdk_nvme_ctrlr_get_regs_vs,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_get_regs_vs</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_vs_register</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_get_regs_vs&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the NVMe controller VS (Version) register.</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L185"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L185" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_get_num_ns"><a name="spdk_nvme_ctrlr_get_num_ns,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_get_num_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_get_num_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the number of namespaces for the given NVMe controller.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the spdk_nvme_ctrlr_data and then reading the nn field.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L191"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L191" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_is_log_page_supported"><a name="spdk_nvme_ctrlr_is_log_page_supported,ptr.spdk_nvme_ctrlr,uint8"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_is_log_page_supported</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
    <span class="Identifier">log_page</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
                          <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_is_log_page_supported&quot;</span><span class="Other">,</span>
                          <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Determine if a particular log page is supported by the given NVMe controller.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>sa spdk_nvme_ctrlr_cmd_get_log_page()</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L204"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L204" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_is_feature_supported"><a name="spdk_nvme_ctrlr_is_feature_supported,ptr.spdk_nvme_ctrlr,uint8"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_is_feature_supported</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
    <span class="Identifier">feature_code</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
                              <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_is_feature_supported&quot;</span><span class="Other">,</span>
                              <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Determine if a particular feature is supported by the given NVMe controller.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>sa spdk_nvme_ctrlr_cmd_get_feature()</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L218"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L218" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_register_aer_callback"><a name="spdk_nvme_ctrlr_register_aer_callback,ptr.spdk_nvme_ctrlr,spdk_nvme_aer_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_register_aer_callback</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
    <span class="Identifier">aer_cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_aer_cb</span><span class="Other">;</span> <span class="Identifier">aer_cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_register_aer_callback&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L252"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L252" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_alloc_io_qpair"><a name="spdk_nvme_ctrlr_alloc_io_qpair,ptr.spdk_nvme_ctrlr,spdk_nvme_qprio"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_alloc_io_qpair</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
                                    <span class="Identifier">qprio</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_qprio</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_alloc_io_qpair&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Allocate an I/O queue pair (submission and completion queue).</p>
<p>Each queue pair should only be used from a single thread at a time (mutual exclusion must be enforced by the user).</p>
<p>param ctrlr NVMe controller for which to allocate the I/O queue pair. param qprio Queue priority for weighted round robin arbitration.  If a different arbitration method is in use, pass 0.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L264"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L264" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_free_io_qpair"><a name="spdk_nvme_ctrlr_free_io_qpair,ptr.spdk_nvme_qpair"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_free_io_qpair</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_free_io_qpair&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair().</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L278"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L278" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_cmd_io_raw"><a name="spdk_nvme_ctrlr_cmd_io_raw,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_qpair,ptr.spdk_nvme_cmd,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_cmd_io_raw</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
                                <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">cmd</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_cmd</span><span class="Other">;</span>
                                <span class="Identifier">buf</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
                                <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_cmd_io_raw&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Send the given NVM I/O command to the NVMe controller.</p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L284"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L284" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_qpair_process_completions"><a name="spdk_nvme_qpair_process_completions,ptr.spdk_nvme_qpair,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_qpair_process_completions</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
    <span class="Identifier">max_completions</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">int32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_qpair_process_completions&quot;</span><span class="Other">,</span>
                                   <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Process any outstanding completions for I/O submitted on a queue pair.</p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<dl class="docutils"><dt>For each completed command, the request's callback function will</dt>
<dd>be called if specified as non-NULL when the request was submitted.</dd>
</dl>
<p>param qpair Queue pair to check for completions. param max_completions Limit the number of completions to be processed in one call, or 0 for unlimited.</p>
<p>return Number of completions processed (may be 0) or negative on error.</p>
<p>sa spdk_nvme_cmd_cb</p>
<dl class="docutils"><dt>This function may be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>The caller must ensure that each queue pair is only used from one thread at a time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L303"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L303" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_cmd_admin_raw"><a name="spdk_nvme_ctrlr_cmd_admin_raw,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_cmd,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_cmd_admin_raw</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
                                   <span class="Identifier">cmd</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_cmd</span><span class="Other">;</span> <span class="Identifier">buf</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                   <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_cmd_admin_raw&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Send the given admin command to the NVMe controller.</p>
<p>This is a low level interface for submitting admin commands directly. Prefer the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L330"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L330" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_process_admin_completions"><a name="spdk_nvme_ctrlr_process_admin_completions,ptr.spdk_nvme_ctrlr"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_process_admin_completions</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">int32</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_process_admin_completions&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Process any outstanding completions for admin commands.</p>
<p>This will process completions for admin commands submitted on any thread.</p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>return Number of completions processed (may be 0) or negative on error.</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L351"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L351" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_get_ns"><a name="spdk_nvme_ctrlr_get_ns,ptr.spdk_nvme_ctrlr,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_get_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">ns_id</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_get_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Get a handle to a namespace for the given controller.</p>
<p>Namespaces are numbered from 1 to the total number of namespaces. There will never be any gaps in the numbering. The number of namespaces is obtained by calling spdk_nvme_ctrlr_get_num_ns().</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L373"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L373" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_cmd_get_log_page"><a name="spdk_nvme_ctrlr_cmd_get_log_page,ptr.spdk_nvme_ctrlr,uint8,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_cmd_get_log_page</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">log_page</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span>
                                      <span class="Identifier">nsid</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                      <span class="Identifier">payload_size</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                      <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_cmd_get_log_page&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Get a specific log page from the NVMe controller.</p>
<p>param ctrlr NVMe controller to query. param log_page The log page identifier. param nsid Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG. param payload The pointer to the payload buffer. param payload_size The size of payload buffer. param cb_fn Callback function to invoke when the log page has been retrieved. param cb_arg Argument to pass to the callback function.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
<p>sa spdk_nvme_ctrlr_is_log_page_supported()</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L386"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L386" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_cmd_set_feature"><a name="spdk_nvme_ctrlr_cmd_set_feature,ptr.spdk_nvme_ctrlr,uint8,uint32,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_cmd_set_feature</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">feature</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span>
                                     <span class="Identifier">cdw11</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cdw12</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                     <span class="Identifier">payload_size</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                     <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_cmd_set_feature&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Set specific feature for the given NVMe controller.</p>
<p>param ctrlr NVMe controller to manipulate. param feature The feature identifier. param cdw11 as defined by the specification for this command. param cdw12 as defined by the specification for this command. param payload The pointer to the payload buffer. param payload_size The size of payload buffer. param cb_fn Callback function to invoke when the feature has been set. param cb_arg Argument to pass to the callback function.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
<p>sa spdk_nvme_ctrlr_cmd_get_feature()</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L413"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L413" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_cmd_get_feature"><a name="spdk_nvme_ctrlr_cmd_get_feature,ptr.spdk_nvme_ctrlr,uint8,uint32,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_cmd_get_feature</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">feature</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span>
                                     <span class="Identifier">cdw11</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                     <span class="Identifier">payload_size</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                     <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_cmd_get_feature&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Get specific feature from given NVMe controller.</p>
<p>param ctrlr NVMe controller to query. param feature The feature identifier. param cdw11 as defined by the specification for this command. param payload The pointer to the payload buffer. param payload_size The size of payload buffer. param cb_fn Callback function to invoke when the feature has been retrieved. param cb_arg Argument to pass to the callback function.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
<p>sa spdk_nvme_ctrlr_cmd_set_feature()</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L441"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L441" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_attach_ns"><a name="spdk_nvme_ctrlr_attach_ns,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_ctrlr_list"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_attach_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">nsid</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                               <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr_list</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_attach_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Attach the specified namespace to controllers.</p>
<p>param ctrlr NVMe controller to use for command submission. param nsid Namespace identifier for namespace to attach. param payload The pointer to the controller list.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L468"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L468" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_detach_ns"><a name="spdk_nvme_ctrlr_detach_ns,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_ctrlr_list"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_detach_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">nsid</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                               <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr_list</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_detach_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Detach the specified namespace from controllers.</p>
<p>param ctrlr NVMe controller to use for command submission. param nsid Namespace ID to detach. param payload The pointer to the controller list.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L486"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L486" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_create_ns"><a name="spdk_nvme_ctrlr_create_ns,ptr.spdk_nvme_ctrlr,ptr.spdk_nvme_ns_data"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_create_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span>
                               <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns_data</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_create_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Create a namespace.</p>
<p>param ctrlr NVMe controller to create namespace on. param payload The pointer to the NVMe namespace data.</p>
<p>return Namespace ID (&gt;= 1) if successfully created, or 0 if the request failed.</p>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L504"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L504" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_delete_ns"><a name="spdk_nvme_ctrlr_delete_ns,ptr.spdk_nvme_ctrlr,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_delete_ns</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">nsid</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_delete_ns&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Delete a namespace.</p>
<p>param ctrlr NVMe controller to delete namespace from. param nsid The namespace identifier.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion of commands submitted through this function.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L518"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L518" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_format"><a name="spdk_nvme_ctrlr_format,ptr.spdk_nvme_ctrlr,uint32,ptr.spdk_nvme_format"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_format</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">nsid</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                            <span class="Identifier">format</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_format</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_format&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Format NVM.</p>
<p>This function requests a low-level format of the media.</p>
<p>param ctrlr NVMe controller to format. param nsid The namespace identifier.  May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces. param format The format information for the command.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request</p>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L534"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L534" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ctrlr_update_firmware"><a name="spdk_nvme_ctrlr_update_firmware,ptr.spdk_nvme_ctrlr,pointer,uint32,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ctrlr_update_firmware</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ctrlr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ctrlr</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                     <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">slot</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ctrlr_update_firmware&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Download a new firmware image.</p>
<p>param payload The data buffer for the firmware image. param size The data size will be downloaded. param slot The slot that the firmware image will be committed to.</p>
<p>return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request,</p>
<table frame="void"><tr><th align="left">-1 if the size is not multiple of 4.</th><td align="left"></td>
</tr>
</table><p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L551"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L551" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_data"><a name="spdk_nvme_ns_get_data,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_data</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns_data</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_data&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the identify namespace data as defined by the NVMe specification.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L567"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L567" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_id"><a name="spdk_nvme_ns_get_id,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_id</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_id&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the namespace id (index number) from the given namespace handle.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L576"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L576" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_is_active"><a name="spdk_nvme_ns_is_active,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_is_active</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_is_active&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Determine whether a namespace is active.</p>
<p>Inactive namespaces cannot be the target of I/O commands.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L585"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L585" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_max_io_xfer_size"><a name="spdk_nvme_ns_get_max_io_xfer_size,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_max_io_xfer_size</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_max_io_xfer_size&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L593"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L593" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_sector_size"><a name="spdk_nvme_ns_get_sector_size,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_sector_size</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_sector_size&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the sector size, in bytes, of the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L602"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L602" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_num_sectors"><a name="spdk_nvme_ns_get_num_sectors,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_num_sectors</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint64</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_num_sectors&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the number of sectors for the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L611"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L611" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_size"><a name="spdk_nvme_ns_get_size,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_size</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint64</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_size&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the size, in bytes, of the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L620"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L620" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_pi_type"><a name="spdk_nvme_ns_get_pi_type,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_pi_type</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_pi_type</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_pi_type&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the end-to-end data protection information type of the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L629"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L629" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_md_size"><a name="spdk_nvme_ns_get_md_size,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_md_size</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_md_size&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief Get the metadata size, in bytes, of the given namespace.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L638"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L638" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_supports_extended_lba"><a name="spdk_nvme_ns_supports_extended_lba,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_supports_extended_lba</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_supports_extended_lba&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd>brief True if the namespace can support extended LBA when end-to-end data protection enabled.<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L647"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L647" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_get_flags"><a name="spdk_nvme_ns_get_flags,ptr.spdk_nvme_ns"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_get_flags</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_get_flags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Get the flags for the given namespace.</p>
<p>See spdk_nvme_ns_flags for the possible flags returned.</p>
<dl class="docutils"><dt>This function is thread safe and can be called at any point while the controller is attached to</dt>
<dd>the SPDK NVMe driver.</dd>
</dl>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L670"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L670" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_write"><a name="spdk_nvme_ns_cmd_write,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_write</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                            <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span> <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                            <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                            <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_write&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a write I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the write I/O param qpair I/O queue pair to submit the request param payload virtual address pointer to the data payload param lba starting LBA to write the data param lba_count length (in sectors) for the write operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries</dt>
<dd>in spdk/nvme_spec.h, for this I/O.</dd>
<dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L701"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L701" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_writev"><a name="spdk_nvme_ns_cmd_writev,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,spdk_nvme_req_reset_sgl_cb,spdk_nvme_req_next_sge_cb"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_writev</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                             <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span> <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                             <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                             <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                             <span class="Identifier">reset_sgl_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_req_reset_sgl_cb</span><span class="Other">;</span>
                             <span class="Identifier">next_sge_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_req_next_sge_cb</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_writev&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a write I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the write I/O param qpair I/O queue pair to submit the request param lba starting LBA to write the data param lba_count length (in sectors) for the write operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function param io_flags set flags, defined in nvme_spec.h, for this I/O param reset_sgl_fn callback function to reset scattered payload param next_sge_fn callback function to iterate each scattered payload memory segment</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L726"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L726" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_write_with_md"><a name="spdk_nvme_ns_cmd_write_with_md,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_write_with_md</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
                                    <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                    <span class="Identifier">metadata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span>
                                    <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
                                    <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                    <span class="Identifier">apptag_mask</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">apptag</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_write_with_md&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a write I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the write I/O param qpair I/O queue pair to submit the request param payload virtual address pointer to the data payload</p>
<dl class="docutils"><dt>param metadata virtual address pointer to the metadata payload, the length</dt>
<dd>of metadata is specified by spdk_nvme_ns_get_md_size()</dd>
</dl>
<p>param lba starting LBA to write the data param lba_count length (in sectors) for the write operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries</dt>
<dd>in spdk/nvme_spec.h, for this I/O.</dd>
</dl>
<p>param apptag_mask application tag mask. param apptag application tag to use end-to-end protection information.</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L754"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L754" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_write_zeroes"><a name="spdk_nvme_ns_cmd_write_zeroes,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_write_zeroes</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
                                   <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span>
                                   <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
                                   <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_write_zeroes&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a write zeroes I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the write zeroes I/O param qpair I/O queue pair to submit the request param lba starting LBA for this command param lba_count length (in sectors) for the write zero operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries</dt>
<dd>in spdk/nvme_spec.h, for this I/O.</dd>
<dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L785"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L785" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_read"><a name="spdk_nvme_ns_cmd_read,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_read</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                           <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span> <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                           <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                           <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_read&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a read I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the read I/O param qpair I/O queue pair to submit the request param payload virtual address pointer to the data payload param lba starting LBA to read the data param lba_count length (in sectors) for the read operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function param io_flags set flags, defined in nvme_spec.h, for this I/O</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L809"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L809" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_readv"><a name="spdk_nvme_ns_cmd_readv,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,spdk_nvme_req_reset_sgl_cb,spdk_nvme_req_next_sge_cb"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_readv</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                            <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span> <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
                            <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                            <span class="Identifier">reset_sgl_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_req_reset_sgl_cb</span><span class="Other">;</span>
                            <span class="Identifier">next_sge_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_req_next_sge_cb</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_readv&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a read I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the read I/O param qpair I/O queue pair to submit the request param lba starting LBA to read the data param lba_count length (in sectors) for the read operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function param io_flags set flags, defined in nvme_spec.h, for this I/O param reset_sgl_fn callback function to reset scattered payload param next_sge_fn callback function to iterate each scattered payload memory segment</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L833"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L833" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_read_with_md"><a name="spdk_nvme_ns_cmd_read_with_md,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,pointer,uint64,uint32,spdk_nvme_cmd_cb,pointer,uint32,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_read_with_md</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
                                   <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                                   <span class="Identifier">metadata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">lba</span><span class="Other">:</span> <span class="Identifier">uint64</span><span class="Other">;</span>
                                   <span class="Identifier">lba_count</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
                                   <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">io_flags</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                                   <span class="Identifier">apptag_mask</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">apptag</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_read_with_md&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a read I/O to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the read I/O param qpair I/O queue pair to submit the request param payload virtual address pointer to the data payload</p>
<dl class="docutils"><dt>param metadata virtual address pointer to the metadata payload, the length</dt>
<dd>of metadata is specified by spdk_nvme_ns_get_md_size()</dd>
</dl>
<p>param lba starting LBA to read the data param lba_count length (in sectors) for the read operation param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function param io_flags set flags, defined in nvme_spec.h, for this I/O param apptag_mask application tag mask. param apptag application tag to use end-to-end protection information.</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L860"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L860" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_deallocate"><a name="spdk_nvme_ns_cmd_deallocate,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint16,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_deallocate</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                                 <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">num_ranges</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span>
                                 <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_deallocate&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a deallocation request to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the deallocation request param qpair I/O queue pair to submit the request</p>
<dl class="docutils"><dt>param payload virtual address pointer to the list of LBA ranges to</dt>
<dd>deallocate</dd>
<dt>param num_ranges number of ranges in the list pointed to by payload; must be</dt>
<dd>between 1 and ref SPDK_NVME_DATASET_MANAGEMENT_MAX_RANGES, inclusive.</dd>
</dl>
<p>param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L890"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L890" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_flush"><a name="spdk_nvme_ns_cmd_flush,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_flush</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span> <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span>
                            <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_flush&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a flush request to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the flush request param qpair I/O queue pair to submit the request param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L913"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L913" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_reservation_register"><a name="spdk_nvme_ns_cmd_reservation_register,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_register_data,bool,spdk_nvme_reservation_register_action,spdk_nvme_reservation_register_cptpl,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_reservation_register</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
    <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_reservation_register_data</span><span class="Other">;</span>
    <span class="Identifier">ignore_key</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span> <span class="Identifier">action</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_register_action</span><span class="Other">;</span>
    <span class="Identifier">cptpl</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_register_cptpl</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
    <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
                          <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_reservation_register&quot;</span><span class="Other">,</span>
                          <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a reservation register to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the reservation register request param qpair I/O queue pair to submit the request param payload virtual address pointer to the reservation register data param ignore_key '1' the current reservation key check is disabled param action specifies the registration action param cptpl change the Persist Through Power Loss state param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L931"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L931" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_reservation_release"><a name="spdk_nvme_ns_cmd_reservation_release,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_key_data,bool,spdk_nvme_reservation_release_action,spdk_nvme_reservation_type,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_reservation_release</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
    <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_reservation_key_data</span><span class="Other">;</span>
    <span class="Identifier">ignore_key</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span> <span class="Identifier">action</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_release_action</span><span class="Other">;</span>
    <span class="Other">`</span><span class="Keyword">type</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_type</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_reservation_release&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a reservation release to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the reservation release request param qpair I/O queue pair to submit the request param payload virtual address pointer to current reservation key param ignore_key '1' the current reservation key check is disabled param action specifies the reservation release action param type reservation type for the namespace param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L957"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L957" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_reservation_acquire"><a name="spdk_nvme_ns_cmd_reservation_acquire,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,ptr.spdk_nvme_reservation_acquire_data,bool,spdk_nvme_reservation_acquire_action,spdk_nvme_reservation_type,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_reservation_acquire</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
    <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_reservation_acquire_data</span><span class="Other">;</span>
    <span class="Identifier">ignore_key</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span> <span class="Identifier">action</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_acquire_action</span><span class="Other">;</span>
    <span class="Other">`</span><span class="Keyword">type</span><span class="Other">`</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_reservation_type</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span> <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_reservation_acquire&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a reservation acquire to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the reservation acquire request param qpair I/O queue pair to submit the request param payload virtual address pointer to reservation acquire data param ignore_key '1' the current reservation key check is disabled param action specifies the reservation acquire action param type reservation type for the namespace param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L981"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L981" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_ns_cmd_reservation_report"><a name="spdk_nvme_ns_cmd_reservation_report,ptr.spdk_nvme_ns,ptr.spdk_nvme_qpair,pointer,uint32,spdk_nvme_cmd_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_ns_cmd_reservation_report</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ns</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_ns</span><span class="Other">;</span>
    <span class="Identifier">qpair</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">spdk_nvme_qpair</span><span class="Other">;</span> <span class="Identifier">payload</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">spdk_nvme_cmd_cb</span><span class="Other">;</span>
    <span class="Identifier">cb_arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_ns_cmd_reservation_report&quot;</span><span class="Other">,</span>
                          <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Submits a reservation report to the specified NVMe namespace.</p>
<p>param ns NVMe namespace to submit the reservation report request param qpair I/O queue pair to submit the request param payload virtual address pointer for reservation status data param len length bytes for reservation status data structure param cb_fn callback function to invoke when the I/O is completed param cb_arg argument to pass to the callback function</p>
<dl class="docutils"><dt>return 0 if successfully submitted, ENOMEM if an nvme_request</dt>
<dd>structure cannot be allocated for the I/O request</dd>
</dl>
<p>The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair(). The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L1005"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L1005" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="spdk_nvme_request_size"><a name="spdk_nvme_request_size,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">spdk_nvme_request_size</span><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">csize</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;spdk_nvme_request_size&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libspdk</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<dl class="docutils"><dt>*</dt>
<dd><p>brief Get the size, in bytes, of an nvme_request.</p>
<p>This is the size of the request objects that need to be allocated by the nvme_alloc_request macro in nvme_impl.h</p>
<p>This function is thread safe and can be called at any time.</p>
</dd>
</dl>

&nbsp;&nbsp;<a
href="/tree/master/api/nvme.nim#L1026"
class="link-seesrc" target="_blank">Source</a>
<a href="/edit/devel/api/nvme.nim#L1026" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2017-02-18 23:24:06 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
